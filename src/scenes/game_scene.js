class GameScene {
  constructor() {
    this.sceneEnded = false;
    this.gravity = 0.008;
    this.ball = new Ball(100, 150);
    var ballupdate = false;
    this.keyboard = new Keyboard();
    this.block = new Block(300, 300);
    this.floorBlock = new FloorBlock(900, 300);
    this.zBlock = new Zblock(900, 600);

    /** @type {Array<Level>} */
    this.levels = [];
    /** @type {Level} */
    this.currentLevel = null;
    Level.load(
      "./src/resources/levels.json",
      function (e, data) {
        /** @type {[]} */
        const allLevelsData = JSON.parse(data);
        allLevelsData.forEach(function (ele) { this.levels.push(new Level(ele)); }, this);
        if (this.levels.length > 0) { this.currentLevel = this.levels[0]; }
      }.bind(this),
      function (e) { console.error("Error in GameScene.constructor() -> level loading"); });

    //The ui bar
    this.ui = new UI();
    //Keep a reference to the items spawned by the UI/Drag and drop
    this.items = this.ui.items;


    //The toolbar object
    this.toolBar = new toolbar();
  }


  restart() {
    this.ball.position.x = 100;
    this.ball.position.y = 150;
    this.ball.acceleration.x = 0;
    this.ball.acceleration.y = 0;
    this.ball.velocity.x = 0;
    this.ball.velocity.y = 0;
    this.ballupdate = false;

  }

  play() {
    this.ballupdate = true;

  }

  delete() {
    this.ui.items.splice(0, this.ui.items.length);
    this.ui.itemsAvailable = [3, 2, 4, 1, 1, 1];


  }
  /**
   * will update all the game scene logic
   * @param {number} dt 
   * time since last update in ms
   */
  update(dt) {

    for (var i in this.items) {
      if (this.items[i] instanceof Spring) {
        if (collisionManager.boolCircleToCircle(this.items[i].collisionCircle, this.ball.collisionCircle)) {
          if (this.items[i].angle === 0) {
            this.ball.impulse(0, -10);
            this.ball.position.y -= this.ball.radius;
          }
          else if (this.items[i].angle === 90) {
            this.ball.impulse(10, 0);
            this.ball.position.x += this.ball.radius;
          }
          else if (this.items[i].angle === 180) {
            this.ball.impulse(0, 10);
            this.ball.position.y += this.ball.radius;
          }
          else {
            this.ball.impulse(-10, 0);
            this.ball.position.x -= this.ball.radius;
          }
          this.items[i].bounce();
        }
     

      } else if (this.items[i] instanceof Block || this.items[i] instanceof FloorBlock) {
        this.squareCollision(this.items[i]);
      } else if (this.items[i] instanceof Zblock) {
        this.Zblock(items[i]);
      }
      //we should be updating all items here, regardless of what they are
      this.items[i].update(dt);
    }


    if (this.ballupdate == true) {
      this.ball.update(dt);
    }
    this.block.update(dt);
    if (this.currentLevel !== null) { this.currentLevel.update(dt, this.ball); }


    this.floorBlock.update(dt);
    this.zBlock.update(dt);

    //Update UI
    this.ui.update(dt);
  }

  squareCollision(item) {
    const result = collisionManager.maniCircleToAABB(this.ball.collisionCircle, item.aabb);
    if (result.collision) {
      GameScene.collisionResponseFromBallToBlock(this.ball, result.manifest);
    }
  }

  /**
   * @param {Ball} ball 
   * @param {{ circle: { distance: {x: number, y: number} }, aabb: { distance: {x: number, y: number} } }} manifest 
   *  Manifest is generated by the external collision manager
   */
  static collisionResponseFromBallToBlock(ball, manifest) {
    const manifestDirection = VectorMath.unit(manifest.circle.distance);
    const velocityDirection = VectorMath.unit(ball.velocity);
    const ballVelocityMag = VectorMath.length(ball.velocity);
    const bounceDirection = {
      x: velocityDirection.x * (manifestDirection.x !== 0 ? manifestDirection.x : 1),
      y: velocityDirection.y * (manifestDirection.y !== 0 ? manifestDirection.y : 1)
    };

    ball.position = {
      x: ball.position.x + manifest.circle.distance.x,
      y: ball.position.y + manifest.circle.distance.y
    };
    ball.velocity = {
      x: bounceDirection.x * ballVelocityMag * -(ball.restitution),
      y: bounceDirection.y * ballVelocityMag * -(ball.restitution)
    };
  }

  zBlock() {

    if (collisionManager.maniCircleToAABB(this.ball.collisionCircle, this.items[i])) {
      if (this.items[i].angle === 0) {
        this.ball.impulse(0, -10);
        this.ball.position.y -= this.ball.radius;
      }
      this.items[i].bounce();
    }

  }





  checkButtonClick(e) {
    //The scene we want to go, leave it empty if we want to stay in the current scene
    var newScene = "";
    let returned = this.toolBar.checkButton(e);

    if (returned === "trash") {
      console.log("Trash");
      this.delete();
    }

    if (returned === "delete") {
      console.log("delete");
    }

    if (returned === "exit") {
      console.log("exit")
      newScene = "this.mManager.setCurrentScene('Main Menu')";
    }

    if (returned === "restart") {
      console.log("restart");
      this.restart();
    }

    if (returned === "play") {
      this.play()
    }

    //Return the new scene
    return newScene;

  }

  /**
   * will draw all the game scene elements
   * @param {CanvasRenderingContext2D} ctx 
   * canvas we want to draw to
   */
  draw(ctx) {
    ctx.fillStyle = "#71f441";
    ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    for (var i in this.items) {
      this.items[i].draw(ctx);
    }

    this.ball.draw(ctx);
    if (this.currentLevel !== null) { this.currentLevel.draw(ctx); }
   // this.zBlock.draw(ctx);
    //Draw the Ui on top of everything else
    this.ui.draw(ctx);
    // this.spring.draw(ctx);
  }
}